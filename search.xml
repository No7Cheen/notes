<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Boot 学习(III) RESTful API]]></title>
    <url>%2Fnotes%2F2018%2F01%2F31%2Fspring-boot-chapter-h1%2F</url>
    <content type="text"><![CDATA[@Controller: 修饰 Class，用来创建处理 Http 请求对象 @RestController: @Controller + @ResponseBody 的终结者 @RequestMapping: 配置 Url 映射 源码参考 RESTful API 设计说明 请求类型 URL 备注 GET /users/ 查询列表 POST /users/ 添加 GET /users/id 根据id查询 PUT /users/id 修改 DELETE /users/id 删除 API 具体设计实体类1234567891011public class UserEntity &#123; public Long id; public String name; public Integer age; public Integer gender; seeter and getter 略&#125; 操作接口 Controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 配置 Class 级别的 RequestMapping，会整个 Class 的映射都在这下面，如果 "/users"@RestController@RequestMapping(value = "/users")public class UserController &#123; // private static Map&lt;Long, UserEntity&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, UserEntity&gt;()); /** * 处理"/users/"的 GET 请求 * &lt;p&gt; * "http://localhost:8080/users/" * * @return List&lt;UserEntity&gt; */ @RequestMapping(value = "/", method = RequestMethod.GET) public List&lt;UserEntity&gt; getUserList() &#123; return new ArrayList&lt;&gt;(users.values()); &#125; /** * 处理"/users/"的 POST 请求 * &lt;p&gt; * "http://localhost:8080/users/" * * @param user 可以使用 @ModelAttribute 绑定参数，还可以通过 @RequestParam 从页面中传递参数 */ @RequestMapping(value = "/", method = RequestMethod.POST) // public UserEntity postUser(@ModelAttribute UserEntity user) &#123; // public UserEntity postUser(@RequestParam UserEntity user) &#123; public UserEntity postUser(@RequestBody UserEntity user) &#123; users.put(user.getId(), user); System.out.println("post add"); System.out.println(user); return users.get(user.getId()); &#125; /** * 处理"/users/&#123;id&#125;"的GET请求，用来获取url中id值的User信息 * &lt;p&gt; * http://localhost:8080/users/1 * * @param id user id * @return UserEntity */ @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.GET) public UserEntity getUser(@PathVariable Long id) &#123; UserEntity userEntity = users.get(id); System.out.println(userEntity); return userEntity; &#125; /** * 处理"/users/&#123;id&#125;"的PUT请求，用来更新User信息 * &lt;p&gt; * "http://localhost:8080/users/1" * * @param id user Id * @param user UserEntity * @return UserEntity */ @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.PUT) public UserEntity putUser(@PathVariable Long id, @RequestBody UserEntity user) &#123; UserEntity entity = users.get(id); entity.setName(user.getName()); entity.setAge(user.getAge()); users.put(id, entity); return entity; &#125; /** * 处理"/users/&#123;id&#125;"的DELETE请求，用来删除User * &lt;p&gt; * "http://localhost:8080/users/1" * * @param id user Id * @return UserEntity */ @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.DELETE) public UserEntity deleteUser(@PathVariable Long id) &#123; return users.remove(id); &#125;&#125; 单元测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = MockServletContext.class)@WebAppConfigurationpublic class HelloApplicationTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloController(), new UserController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo("Hello World!!!"))); &#125; @Test public void testUserController() throws Exception &#123; UserEntity user = new UserEntity(); user.id = 1L; user.name = "测试Name-" + user.id; user.gender = 1; user.age = 20; // get user列表，第一次应该为空 RequestBuilder request = get("/users/") .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE); String responseString = mvc.perform(request) .andExpect(status().isOk()) .andDo(MockMvcResultHandlers.print()) .andExpect(content().string(equalTo("[]"))) .andReturn().getResponse().getContentAsString(); System.out.println("Get--------返回的json = " + responseString); // post user request = post("/users/") .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE) .content(JSON.toJSONString(user)); responseString = mvc.perform(request) .andExpect(status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn().getResponse().getContentAsString(); Assert.assertEquals(user, JSON.parseObject(responseString, UserEntity.class)); Assert.assertEquals(user.toString(), JSON.parseObject(responseString, UserEntity.class).toString()); System.out.println("Put--------返回的json = " + user.toString()); System.out.println("Put--------返回的json = " + JSON.parseObject(responseString, UserEntity.class).toString()); System.out.println("Put--------返回的json = " + responseString); // get user列表，应该有刚才插入的数据 request = get("/users/") .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE); responseString = mvc.perform(request) .andExpect(status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn().getResponse().getContentAsString(); System.out.println("Get--------返回的json = " + responseString); // put 修改 user user.age = user.age + 1; user.name = user.name + "-put"; request = put("/users/" + user.getId()) .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE) .content(JSON.toJSONString(user)); responseString = mvc.perform(request) .andExpect(status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn().getResponse().getContentAsString(); System.out.println("Put--------返回的json = " + responseString); // get user request = get("/users/" + user.id); responseString = mvc.perform(request) .andExpect(status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn().getResponse().getContentAsString(); System.out.println("Get id--------返回的json = " + responseString); // delete user request = delete("/users/" + user.id); responseString = mvc.perform(request) .andExpect(status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn().getResponse().getContentAsString(); System.out.println("Delete--------返回的json = " + responseString); // get user 列表，应该为空 request = get("/users/"); responseString = mvc.perform(request) .andExpect(status().isOk()) .andDo(MockMvcResultHandlers.print()) .andExpect(content().string(equalTo("[]"))) .andReturn().getResponse().getContentAsString(); System.out.println("删除后的列表应该为空--------返回的json = " + responseString); &#125; @Test public void contextLoads() &#123; &#125;&#125; 至此，在没有做其他任何配置的情况下，以非常简洁的代码完成了对 UserEntity 对象的 RESTful API 的创建以及单元测试。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[补码]]></title>
    <url>%2Fnotes%2F2018%2F01%2F24%2Ftwos-complement%2F</url>
    <content type="text"><![CDATA[这里只是粗浅的了解原码、反码及补码的形式和基本概念，如需深入理解，可参考阮一峰的两篇博文：理解字节序 和 关于2的补码 基本概念机器数机器数(Computer Number)是指一个数在计算机中的二进制表示形式。机器数是带符号的，在计算机中用一个数的最高位存放符号，0 表示正数，1 表示负数。 比如，十进制数「+3」，计算机字长为8位，转换成二进制就是00000011。如果是「-3」，就是 10000011。 那么，这里的 00000011 和 10000011 就是机器数。 机器数有2个特点：一是符号数字化二是其数的大小受机器字长的限制 真值因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位 1 代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。 比如：0000 0001的真值 = +000 0001 =「+1」1000 0001的真值 = –000 0001 =「–1」 机器码的原码、反码、补码的三种表示形式对于一个数，计算机要使用一定的编码方式进行存储。机器存储一个具体数字的编码方式包括：原码、反码、补码。 原码原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。这也是人脑最直观，最容易和计算的表示方式。 如(字长为8)[+1]原 = 0000 0001[-1]原 = 1000 00018位二进制的范围为[1111 1111 , 0111 1111]，即[-127,127] 反码反码的表示方法是： 正数的反码是其本身； 负数的反码是在其原码的基础上，符号位不变，其余各个位取反； [+1]=[0000 0001]原 = [0000 0001]反[-1]=[1000 0001]原 = [1111 1110]反 补码补码的表示方法是： 正数的补码就是其本身； 负数的补码是在其原码的基础上，符号位不变，其余各位取反(~)，最后「+1」(即在反码的基础上 +1)； [+1] = [0000 0001]原 = [0000 0001]反 = [0000 0001]补[-1] = [1000 0001]原 = [1111 1110]反 = [1111 1111]补 需要注意：补码的补码还是原码，就是说补码转原码和原码转补码的方法是一样的，取反+1。 为何要用补码原码表示法比较直观，它的数值部分就是该数的绝对值，而且与真值、十进制数的转换十分方便。既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢?原码的表示是最直观易懂的，但是它的加减法运算较复杂。机器首先要判断两数的符号，还要判断两数绝对值大小，等等，显然，这种计算会让计算机的基础电路变得十分复杂。 于是人们开始探索 将符号位参与运算, 并且只保留加法的方法。 计算十进制的表达式： 1 - 1 = 01 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [1000 0010]原 = -2 可以看到，如果用原码表示，让符号位也参与计算，显然对于减法来说结果是不正确的。 为了解决上面原码做减法的问题，于是，出现了反码： 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0 发现用反码计算减法，结果的真值部分是正确的。现在，唯一的问题就出现在“0”这个特殊的数值上。虽然理解上 +0 和 -0 是一样的，但是0带符号是没有任何意义的。而且这样0的编码就出现了2个：[0000 0000]原 和 [1000 0000]原。 于是补码就出现了： 1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原 这样 0 用 [0000 0000] 表示，这样-0的问题就不存在了。而且可以用 [1000 0000] 表示 -128 ：(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补 -1-127 的结果应该是 -128，在补码的运算过程中 [1000 0000]补 就被用作 -128。这里需要特别注意的是，-128 的的表现形式实际上用的是 -0 的补码，所以 -128 并没有原码和反码(对 -128 的补码表示[1000 0000]补算出来的原码是[0000 0000]原，这是不正确的)。 使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用原码或反码表示的范围为[-127, +127]，而使用补码表示的范围为[-128, 127]。 因为机器使用补码，所以对于编程中常用到的 32 位 int 类型，可以表示范围是：[-2^31, 2^31-1] 因为第一位表示的是符号位。而使用补码表示时又可以多保存一个最小值。 附最后简单补充以下 Java 基本数据类型： 类型 字节数 类名称 范围 byte 1字节(8位) Byte [-2^8, 2^8-1], 即 -128 ～ 127 short 2字节(16位) Short [-2^16, 2^16-1], 即 -32768 ～ 32767 int 4字节(32位) Integer [-2^31, 2^31-1] long 8字节(64位) Long [-2^64, 2^64-1] float 4字节(32位) Float - double 8字节(64位) Double -]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android HTTPS SSL 双向验证（自签名证书）]]></title>
    <url>%2Fnotes%2F2018%2F01%2F17%2FAndroid-https-ssl-two-way%2F</url>
    <content type="text"><![CDATA[前段时间做一个基于「发布/订阅(publish/subscribe)」模式的“轻量级”通讯协议。连接 MQTT 时，为了保证服务器数据安全，保证接口不暴露给第三方，要求客户端接口全部采用 HTTPS 的 SSL 验证请求。本博介绍的是自签名证书。 HTTPS 与 HTTP http 是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议 http 与 https 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443 http 连接很简单，无状态；https 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全 https 协议需要到 ca 申请证书。一般免费证书很少，需要交费 SSLSSL协议位于「TCP/IP」协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层，即：「SSL记录协议」和「SSL握手协议」。 SSL协议层级概念「SSL记录协议」（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 「SSL握手协议」（SSL Handshake Protocol），它建立在「SSL记录协议」之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 功能 客户对服务器的身份认证 SSL服务器允许终端（如：浏览器）使用标准的公钥加密技术和一些可靠的认证中心（CA）的证书来确认服务器的合法性。 服务器对客户的身份认证 可通过公钥技术和证书进行认证，也可通过用户名、password 来认证。 建立服务器与客户之间安全的数据通道 SSL要求客户与服务器之间的所有发送的数据都被发送端加密、接收端解密，同时还检查数据的完整性。 密钥库和证书（仅供参考，未验证）1234567891011121314151617181920# 生成服务器证书库 server.keystorekeytool -validity 365 -genkey -v -alias server -keyalg RSA -keystore server.keystore -dname &quot;CN=127.0.0.1,OU=rongyiwang,O=rongyiwang,L=Shanghai,ST=Shanghai,c=cn&quot; -storepass 123456 -keypass 123456# 生成客户端证书库 client.p12keytool -validity 365 -genkeypair -v -alias client -keyalg RSA -storetype PKCS12 -keystore client.p12 -dname &quot;CN=client,OU=rongyiwang,O=rongyiwang,L=Shanghai,ST=Shanghai,c=cn&quot; -storepass 123456 -keypass 123456# 从客户端证书库中导出客户端证书 client.p12、client.cerkeytool -export -v -alias client -keystore client.p12 -storetype PKCS12 -storepass 123456 -rfc -file client.cer# 从服务器证书库中导出服务器证书 server.keystorekeytool -export -v -alias server -keystore server.keystore -storepass 123456 -rfc -file server.cer# 生成客户端信任证书库(由服务端证书生成的证书库) server.cer client.truststorekeytool -import -v -alias server -file server.cer -keystore client.truststore -storepass 123456 -storetype BKS -provider org.bouncycastle.jce.provider.BouncyCastleProvider# 将客户端证书导入到服务器证书库(使得服务器信任客户端证书) client.cerkeytool -import -v -alias client -file client.cer -keystore server.keystore -storepass 123456# 查看证书库中的全部证书keytool -list -keystore server.keystore -storepass 123456 Android SSL 认证需要注意的是，安卓端的证书必须是BKS类型。下面的验证方式使用了「client.bks」和「keycert.p12」 SslSocketFactory 方式进行 SSL 认证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 双向验证 */private fun getSSLSocketFactory(): SSLSocketFactory? &#123; try &#123; // 取得SSL的SSLContext实例，使用协议SSL val sslContext = SSLContext.getInstance("SSL") // 取得KeyManagerFactory和TrustManagerFactory的X509密钥管理器实例 val keyManager = KeyManagerFactory.getInstance("X509") val trustManager = TrustManagerFactory.getInstance("X509") // 取得BKS密库实例 val kks = KeyStore.getInstance("BKS") val tks = KeyStore.getInstance("PKCS12") // 加客户端载证书和私钥, 通过读取资源文件的方式读取密钥和信任证书 client.bks val keyStore = FoundationContext.context.assets.open("client.bks") kks.load(keyStore, BKS_PASSWORD.toCharArray()) val trustStore = FoundationContext.context.assets.open("keycert.p12") tks.load(trustStore, BKS_PASSWORD.toCharArray()) // 初始化密钥管理器 keyManager.init(kks, BKS_PASSWORD.toCharArray()) trustManager.init(tks) // 初始化SSLContext sslContext.init(keyManager.keyManagers, trustManager.trustManagers, null) // 生成SSLSocket // Client_sslSocket = // sslContext.socketFactory.createSocket(SERVER_IP, SERVER_PORT) as SSLSocket return sslContext.socketFactory &#125; catch (e: KeyStoreException) &#123; Logger.e(e) &#125; catch (e: CertificateException) &#123; Logger.e(e) &#125; catch (e: IOException) &#123; Logger.e(e) &#125; catch (e: NoSuchAlgorithmException) &#123; Logger.e(e) &#125; catch (e: KeyManagementException) &#123; Logger.e(e) &#125; catch (e: UnrecoverableKeyException) &#123; Logger.e(e) &#125; catch (e: MqttException) &#123; Logger.e(e) &#125; return null&#125; SSLContext 方式进行 SSL 认证方法同上，将 sslContext.socketFactory 去掉，直接返回 sslContext 即可。]]></content>
      <categories>
        <category>Android</category>
        <category>Https</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 创建本地和远程分支]]></title>
    <url>%2Fnotes%2F2018%2F01%2F03%2FGit-branch-create%2F</url>
    <content type="text"><![CDATA[Git 默认只有一个主干分支，即 master。通常，我们的工作不会直接在 master 上进行，而是使用一个单独的分支，如：dev，最后进行分支的合并。 关于分支的理解，请参考：Git 分支 - 分支的新建与合并，Git 分支 - 远程分支，Git 分支 - 何谓分支，创建与合并分支 分支命令下面给出创建本地和远程分支的完整命令： 1234567$ git checkout -b dev/devSwitched to branch &apos;dev/dev&apos;$ git push origin dev/devTotal 0 (delta 0), reused 0 (delta 0)To git.dev.sh.ctripcorp.com:hotel_m/PioneerAndroid.git * [new branch] dev/dev -&gt; dev/dev git checkout -b dev/dev 是下面两条命令的简写：$ git branch dev/dev$ git checkout dev/dev 体验]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 常用快捷键]]></title>
    <url>%2Fnotes%2F2017%2F12%2F13%2Fmac-macos-shortcuts%2F</url>
    <content type="text"><![CDATA[记录几个经常用到的快捷键，便于翻阅 快捷键 描述 Command + Q 退出应用（强制完全退出） Command + W 关闭窗口 Command + M 最小化 Command + N 新建窗口 Command + , 偏好设置 Finder 快捷键 描述 Command + Shift + H Home目录 Command + Shift + . 显示隐藏文件 Command + Option + C 复制文件路径 Command + Option + V 剪切文件 屏幕截图 快捷键 描述 Command + Shift + 3 截屏屏幕并保存到桌面 Command + Shift + 4 选定区域截图或按空格选定窗口后点击鼠标左键截图，截图文件保存在桌面 Command + Control + Shift + 3 截屏屏幕并保存到剪切板 Command + Control + Shift + 4 选定区域截图或按空格选定窗口后点击鼠标左键截图，截图文件保存在剪切板]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>macOs</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 显示隐藏文件的快捷键]]></title>
    <url>%2Fnotes%2F2017%2F12%2F13%2Fmac-shortcuts-to-show-hiden-files-in-macos-sierra%2F</url>
    <content type="text"><![CDATA[在 MacOS Sierra 之前，在 Finder 中查看隐藏文件，都要输入一坨命令： 1defaults write com.apple.finder AppleShowAllFiles -bool true 上面只是显示了隐藏的文件，可是你用完了呢，还得输入一坨类似的命令再隐藏起来。为了方便使用这死玩意，想尽了各种办法，收藏命令、存脚本、iTerm Alias 等等各种折腾，但都不足以达到一个便捷的操作效果，我们真正需要的是“用完即走”。 macOS Sierra 开始，上面那些繁琐的方式我们可以统统丢掉了，因为~ 快捷键来了： 1Command + Shift + .]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>macOs</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 学习(II) 配置文件]]></title>
    <url>%2Fnotes%2F2017%2F12%2F06%2Fspring-boot-chapter-2%2F</url>
    <content type="text"><![CDATA[可以发现，在使用「Spring Boot」的过程中，我们只需要很少的配置就能完成相应的功能，这归功于「Spring Boot」中的模块化配置，在 pom.xml 中依赖的每个 Starter 都有默认配置，而这些默认配置足以满足正常的功能开发。 如何自定义配置，「Spring Boot」为我们提供了很简捷的方式，只需要在 application.properties 中添加修改相应的配置即可。「Spring Boot」在启动的时候会读取这份默认配置。 默认配置这里以修改默认端口为例说明一下怎样修改默认配置，Tomcat 启动 Spring Boot Web 应用的默认端口是8080，现在我们试着修改默认端口为8088，其实很简单，只需在 application.properties 中添加一个名为 server.port 的记录即可： 1server.port=8088 接着，重启，访问 http://localhost:8088。 附：application.properties 全部配置项，点击查看所有配置说明 自定义属性application.properties 中除了可以修改默认配置，还可以配置自定义的属性，并在实体 Bean 中加载出来。 12issexplorer.notes.title=iSSExplorer&apos;s Notesissexplorer.notes.subTitle=Quick notes 加载对应的配置属性通常有2种方式： 一种是通过 @Value(&quot;${属性名}&quot;)一种是通过 @ConfigurationProperties(prefix=&quot;&quot;)设置前缀，属性上不需要添加注解 在加载配置属性之前，首先需将下面的配置加入 pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 12345678910111213141516171819/** * 自定义 Notes 配置 * &lt;p&gt; * 添加 @Component 注解，让 Spring 在启动的时候扫描到该类，并添加到 Spring 容器中 */@Componentpublic class ConfigProperties4NotesBean &#123; @Value("$&#123;issexplorer.notes.title&#125;") private String title; @Value("$&#123;issexplorer.notes.subTitle&#125;") private String subTitle; @Value("$&#123;issexplorer.notes.desc&#125;") private String desc; // setter and getters 省略。。。&#125; @Component：让 Spring 在启动的时候扫描到该 Bean 类，并添加到 Spring 容器中 1234567891011@Component@PropertySource("classpath:application.properties")@ConfigurationProperties(prefix = "issexplorer.notes.random")public class ConfigProperties4NotesBean &#123; private String title; private String subTitle; private String desc; // setter and getters 省略。。。&#125; @PropertySource：指定配置文件 @ConfigurationProperties(prefix=””)：设置前缀 @Component：让 Spring 在启动的时候扫描到该 Bean 类，并添加到 Spring 容器中 在 Controller 中注入并使用这个 Bean: 12345678910111213141516171819202122@RestControllerpublic class HelloController &#123; @Autowired private ConfigProperties4NotesBean notesConfig; @RequestMapping("/") public String index() &#123; return "Hello World!!!"; &#125; /** * 测试配置信息 * * @return &#123;"title":"iSSExplorer's Notes","subTitle":"Quick notes","desc":"iSSExplorer's Notes Quick notes"&#125; */ @RequestMapping("/configNotes") public ConfigProperties4NotesBean configNotes() &#123; return notesConfig; &#125; &#125; 访问：http://localhost:8080/configNotes 参数间的引用在 application.properties 中，各个参数之间也可以直接引用来使用，就像下面的设置： 1234# 自定义属性、参数间引用issexplorer.notes.title=iSSExplorer&apos;s Notesissexplorer.notes.subTitle=Quick notesissexplorer.notes.desc=$&#123;issexplorer.notes.title&#125; $&#123;issexplorer.notes.subTitle&#125; issexplorer.notes.desc 参数引用了上文中定义的 title 和 subTitle 属性，最后该属性的值就是 iSSExplorer&#39;s Notes Quick notes 随机数的使用某些情况下，有些参数我们需要希望它不是一个固定的值，比如密钥、服务端口等。「Spring Boot」属性配置文件中可以通过 ${random} 来产生 int值、long值或者 String字符串，来支持属性的随机值。 12345678910111213# 随机数# 随机字符串issexplorer.notes.random.value=$&#123;random.value&#125;# 随机intissexplorer.notes.random.number=$&#123;random.int&#125;# 随机longissexplorer.notes.random.bigNumber=$&#123;random.long&#125;# 10以内的随机数issexplorer.notes.random.count=$&#123;random.int(10)&#125;# 10-20的随机数issexplorer.notes.random.rankNumber=$&#123;random.int[10,20]&#125;# 获取随机uuidissexplorer.notes.random.uuid=$&#123;random.uuid&#125; 命令行设置属性值 (不推荐)在命令行运行时，连续的两个减号 -- 就是对 application.properties 中的属性值进行赋值的标识。如，java -jar xxx.jar --server.port=8888（通过使用 –server.port 属性来设置 xxx.jar 应用的端口），等价于我们在 application.properties 中添加属性 server.port=8888。 出于安全考虑，通过命令行设置属性值的方式这里不推荐使用。「Spring Boot」也是早考虑到了这点，为我们提供了简单的屏蔽方式： 12345678910111213141516@SpringBootApplicationpublic class SpringbootconfigApplication &#123; public static void main(String[] args) &#123; // SpringApplication.run(SpringbootconfigApplication.class, args); Object[] sources = new Object[]&#123;SpringbootconfigApplication.class&#125;; SpringApplication springApplication = new SpringApplication(sources); // 禁止命令行设置参数 springApplication.setAddCommandLineProperties(false); springApplication.run(args); &#125; &#125; 多环境配置在实际开发中可能会有不同环境，开发、测试、生成等。对于每个环境相关配置都可能有所不同，如：数据库信息、端口配置、本地路径配置等。 如果每次切换不同环境都需要修改 application.properties，那么操作是十分繁琐的。在「Spring Boot」中提供了多环境配置，使得我们切换环境变得简便。多环境配置文件名需要满足 application-{profile}.properties 的格式，其中 {profile} 对应你的环境标识，比如： 123application-dev.properties // 开发环境的配置文件application-test.properties // 测试环境的配置文件application-prod.properties // 生产环境的配置文件 至于哪个具体的配置文件会被加载，需要在 application.properties 文件中通过 spring.profiles.active 属性来设置，其值对应 {profile} 的值。 12345spring.profiles.active=dev# 引用测试的配置文件# spring.profiles.active=test# 引用生产的配置文件# spring.profiles.active=prod 完整示例springbootconfig 附：配置方式和优先级a. 命令行参数b. 来自 java:comp/env 的 JNDI 属性c. Java 系统属性（System.getProperties()）d. 操作系统环境变量e. RandomValuePropertySource 配置的 random.* 属性值f. Jar 外部的 application-{profile}.properties 或 application.yml(带spring.profile)配置文件g. Jar 内部的 application-{profile}.properties 或 application.yml(带spring.profile)配置文件h. Jar 外部的 application.properties 或 application.yml(不带spring.profile)配置文件i. Jar 内部的 application.properties 或 application.yml(不带spring.profile)配置文件j. @Configuration 注解类上的 @PropertySourcek. 通过 SpringApplication.setDefaultProperties 指定的默认属性 补充：在「Spring Boot」中配置除了支持 application.properties，还支持 application.yml 的配置方式 1234567server: port: 9999issexplorer.notes.title: notes: title: iSSExplorer&apos;s Notes subTitle: Quick notes]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 学习(I) HelloWorld]]></title>
    <url>%2Fnotes%2F2017%2F12%2F04%2Fspring-boot-chapter-1%2F</url>
    <content type="text"><![CDATA[「Spring Boot」由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。是否真的是一个简化版的框架，对比使用 Spring 框架就知道了，你只需要 run 就可以创建一个独立的，产品级别的 Spring 应用。 「Spring Boot」并不是一门新技术，从本质上讲，它就是一个 Spring，只是它做了那些没有它你也会去做的 Spring Bean 配置。使用「Spring Boot」你可以不用或者只需要很少的Spring配置。 「Spring Boot」的主要优点： 为所有 Spring 开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化 Web 项目 没有冗余代码生成和 XML 配置的要求 快速入门本章主要目标完成「Spring Boot」基础项目的构建，并且实现一个简单的 Http 请求处理，通过这个例子对「Spring Boot」有一个初步的了解，并体验其结构简单、开发快速的特性。 构建项目本文采用Java 1.8.0_20、Spring Boot 1.5.9.RELEASE。 构建一个「Spring Boot」的 Maven 项目，强烈推荐SPRING INITIALIZR，从本质上来说它就是一个 Web 应用程序，它能为你生成「Spring Boot」项目结构。 通过 Web 界面创建 访问：http://start.spring.io/ 选择构建工具 Maven Project、Spring Boot版本1.5.9以及一些工程基本信息，可参考下图所示 点击 Generate Project 下载项目压缩包 解压项目包，并用 IDE 以 Maven 项目导入 菜单中选择 File → New → Project from Existing Sources...选择解压后的项目文件夹，点击 OK点击 Import project from external model 并选择 Maven，点击 Next 到底为止 通过「IntelliJ IDEA」创建（推荐） 打开 IDEA 启动界面 Create New Project，或者 File → New → Project，接着如下图一步步操作即可。 根据上面的操作已经初始化了一个 Spring Boot 的框架了，项目结构如下： 项目里面基本没有代码，除了几个空目录外，还包含如下几样东西。 src/main/java 源码目录：SpringbookhelloworldApplication.java，一个带有 main() 方法的类，用于启动应用程序 src/main/resources 资源配置目录：包含一个名为 application.properties 的空的 properties 文件，可根据需要添加配置属性 src/test，测试源码目录：SpringbookhelloworldApplicationTests.java，一个空的 Junit 测试类，它加载了一个使用 Spring Boot 字典配置功能的 Spring 应用程序上下文 pom.xml：Maven 构建说明文件 Pom.xml「Spring Boot」父级依赖123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 有了这个「Spring Boot」父级依赖，当前项目才是「Spring Boot」项目。 spring-boot-starter-parent 是一个特殊的 starter，用来提供相关的 Maven 默认依赖，使用它之后，常用的包依赖可以省去 version 标签。 「Spring Boot」提供了哪些 jar 包的依赖，可在项目中展开 External Libraries 查看。 当然，默认依赖也是可覆盖替代的。例如，要升级到另一个 Spring Data 版本系列，您可以将以下内容添加到 pom.xml 中： 123&lt;properties&gt; &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;&lt;/properties&gt; Web 模块引入 Web 模块，需添加 spring-boot-starter-web 模块，默认已添加： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; Maven 插件123456&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt;&lt;/plugins&gt; Spring Boot Maven 插件提供了许多方便的功能： 把项目打包成一个可执行的超级 JAR(uber-JAR),包括把应用程序的所有依赖打入 JAR 文件内，并为 JAR 添加一个描述文件，其中的内容能让你用 java -jar 来运行应用程序 搜索 public static void main() 方法来标记为可运行类 HelloWorld 服务 创建 package，命名为 com.issexplorer.web（根据自己的喜好来即可） 创建 HelloController.java，内容如下 123456789@RestControllerpublic class HelloController &#123; @RequestMapping("/hello") public String index() &#123; return "Hello World!"; &#125; &#125; @RestController 注解等价于 @Controller + @ResponseBody，使用这个注解的类里面的方法以 json 格式输出 注意，「Spring Boot」建议我们将 main 方法所在的这个主要的配置类配置在根包名下，类似如下的结构： 1234567891011121314com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- web +- CustomerController.java 启动主程序，访问 http://localhost:8080/hello，可以看到页面输出 Hello World!]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 15.0(16.+) 激活]]></title>
    <url>%2Fnotes%2F2017%2F11%2F30%2Fintellij-idea-license-activation%2F</url>
    <content type="text"><![CDATA[激活 IntelliJ IDEA 选择激活服务器 填入以下地址便可成功激活 http://idea.iteblog.com/key.php 点击 help → Register → License sever, 输入 http://idea.iteblog.com/key.php]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Mark</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 学习（二）常用操作符]]></title>
    <url>%2Fnotes%2F2017%2F11%2F22%2Fkotlin-2%2F</url>
    <content type="text"><![CDATA[类型检测及自动类型转换「is」「is」 检查某个实例是否是某个类型。 如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换： 1234567891011// Startfun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // `obj` 在该条件分支内自动转换成 `String` return obj.length &#125; // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型 return null&#125;// End 或者 12345678// Startfun getStringLength(obj: Any): Int? &#123; if (obj !is String) return null // `obj` 在这一分支自动转换为 `String` return obj.length&#125;// End 甚至 12345678910// Startfun getStringLength(obj: Any): Int? &#123; // `obj` 在 `&amp;&amp;` 右边自动转换成 `String` 类型 if (obj is String &amp;&amp; obj.length &gt; 0) &#123; return obj.length &#125; return null&#125;// End 类型转换「as」和安全转换「as?」除了上面介绍的自动类型转化「is」，我们还可以使用关键字「as」对一个变量进行类型转化。 1val x: String = y as String 注意，上面的表达式中 y 为 null 时会抛出异常。 上面的的类型转换可以改进如下： 1val x: String? = y as String? 当使用「as」转型的时候，如果类型转换失败就会抛出异常 ClassCastException。 所以，现在可以使「as?」安全转型，当转型不成功的时候，它会返回 null。 1val x: String? = y as? String 建议，为安全起见尽量避免使用「as」，改用「as?」是最好的选择。 二目运算符（Elvis Operator）「?:」Java 和 C 里面三目运算是很常见的，其实就是 if-else 的简写形式。看一个简单的 Java 三目运算表达式： 1String y = (x != null) ? x : "" 在 Kotlin 有专门的运算符，即「?:」，「?:」将表达式分为前后（左右）两部分，前部分进行判断并返回其结果，否则返回后部分的结果。上面 Java 对应的 Kotlin 写法： 1val y = x != null ?: "" 强制解包运算符「!!」「!!」，暂且叫它强制解包吧。 12var x: String? = "x"val y: Int = x!!.length 值得注意的是，「!!」用于可以为空的的引用（如上面的的x），当值不为空时，为正常运行；当值为空时，抛出异常 NullPointerException。 冒号「:」「:」冒号之于 Kotlin 太常见了，类型声明、继承、函数返回等。 类型和超类型之间的冒号前要有一个空格，而实例和类型之间的冒号前不要有空格： 12345678910// 定义全局变量时var str: String? = nullinterface Foo&lt;out T : Any&gt; : Bar &#123; fun foo(a: Int): T&#125;// 类的继承与变量定义class KotlinTestActivity&lt;T : Serializable&gt;(name: String) : Activity() &#123;&#125; 范围操作符「..」以及「in」范围操作符可以用来做迭代操作，是用in来实现的。 以下是使用区间的一些示例： 123if (i in 1..4) print(i) // 等同于 1 &lt;= i &amp;&amp; i &lt;= 4, 输出“1234”for (i in 4..1) print(i) // 什么都不输出 倒序操作 downTo 1for (i in 4 downTo 1) print(i) // 输出“4321” 控制迭代的步长，使用step() 123for (i in 1..4 step 2) print(i) // 输出“13”for (i in 4 downTo 1 step 2) print(i) // 输出“42” in 是一个闭区间范围，如果要创建一个不包括其结束元素的区间，可以使用 until 函数 123for (i in 1 until 10) &#123; // i in [1, 10) 排除了 10 println(i)&#125; 多行输入符 三个双引号多行文本符，也就是说在三引号之间输入的内容将被原样保留，之中的单号和双引号不用转义，其中的不可见字符比如 /n 和 /t 都会被保留。 1234567valstr = """ one two """//等价于val str = "one\ntwo"val str = "one"+"\n"+"two"]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 学习（一）基本语法]]></title>
    <url>%2Fnotes%2F2017%2F11%2F22%2Fkotlin-1%2F</url>
    <content type="text"><![CDATA[Kotlin 是 JetBrains 开发的基于 JVM 的语言。可以同 Java 无缝对接，也就是说用 Kotlin 可以直接调用已有的 Java 库。这段时间在用 Kotlin 开发 Android APP 的功能模块，边学边用，边用边学。本博记录下 Kotlin 相关的一些知识点，参考内容主要来自于 Kotlin的官网。 定义包包的声明应处于源文件顶部，源文件所有内容（无论是类还是函数）都包含在声明的包内。如下所示，方法 baz() 的全名就是 foo.bar.baz()，Goo 的全名就是 foo.bar.Goo。 12345package foo.barfun baz() &#123;&#125;class Goo &#123;&#125; 如果没有指明包，该文件的内容属于无名字的默认包。 引入包，使用 import 关键字，与 Java 相同： 123import foo.barimport java.util.*import foo.bar as barAlias 注意：上面的 as 关键字，即引入包名的一个别名，这时，在使用的时候可用别名 barAlias 替代 bar 定义函数Kotlin 中的函数使用 fun 关键字声明，具体参考 函数。 这里给出几种常见的函数表示方式，FYI: 1234567891011121314151617// 定义一个返回值为 Int, 并需要 2 个 Int 参数的函数fun sum(a: Int, b: Int): Int &#123; return a + b&#125;// 函数 sum 的简写方式fun sum(a: Int, b: Int): Int = a + b// 无返回值的函数，使用 Unit, 或者省略 Unitfun sum(a: Int, b: Int): Unit &#123; print(a + b)&#125;// 带有默认参数的函数fun sum(a: Int = 0, b: Int): Int &#123; return a + b&#125; 定义常量和变量Kotlin 可变属性的声明可以用关键字 var，否则使用只读关键字 val。 对于变量和常量我们需要指定其类型，如果在定义的时候给定了初始值，则 Kotlin 可以直接根据赋值推断出变量的类型，这时，类型的指定可以省略。 1234val a: Int = 0val b = 1f // 可推断出类型为 Floatvar name: String? = .... 声明属性的完整语法： 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 上面只是最最简单的一个介绍，具体参考：属性和字段 字符串模板字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成: 12val i = 10val s = "i = $i" // 求值结果为 "i = 10" 或者用花括号括起来的任意表达式: 12val s = "abc"val str = "$s.length is $&#123;s.length&#125;" // 求值结果为 "abc.length is 3" 原生字符串和转义字符串内部都支持模板。 如果你需要在原生字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法： 123val price = """$&#123;'$'&#125;9.99""" 条件表达式与 Java 相同，对条件的判断也是使用 if else。不同之处是 if else 可以直接作为一个表达式赋值给一个变量或者定义为一个方法。 12345// 定义一个方法fun max(a: Int, b: Int) = if (a &gt; b) a else b// 定义一个变量val max = if (a &gt; b) a else b 在 Kotlin 中，if 是一个表达式，即它会返回一个值。 因此就不需要三元运算符（条件 ? 然后 : 否则），因为普通的 if 就能胜任这个角色。 各种控制流（如：for、when），参考：控制流 Null 检测看到 Null，我们就能联想到让我们深恶痛绝的 NullPointerException，这应该是所有搞 Java 开发的同学的共识吧，这玩意带来的毁灭性的系统崩溃实在是太多太多，也太常见了。然后，我们不得不添加一大堆 if(xxx != null) 之类的判定语句。这个也是 Kotlin 一开始吸引我的地方吧。 Kotlin 在 Null 检测方面可以说做的更佳体贴程序员。 12var a: String = "abc"a = null // 编译错误 对于允许为 null 的变量，我们需要加上关键字 ? 来告诉编译器，使用过程中使用语法 ?. 即可。 1234var b: String? = "abc"b = null // OKval len = b?.length // OK，注意这里使用了 ?.， 如果直接访问 b.lenght，在 b 为 null 时仍会异常 b?.length，当 b 为 null 时不会抛出 NullPointerException，而是返回 null；非 null 情况下，返回 b.length，这样就不需要在访问 b.length 之前使用 if(b != null) 了。 现，我们假设一个 Class A 有一个成员变量 b，b 为 Class B 类型，B 有成员变量 c，现在我们要用一个 A 类型的对象 a 访问 c。传统的 Java 写法： 1234String tmp;if(a != null &amp;&amp; a.b != null) &#123; tmp = a.b.c;&#125; 看看上面的代码，显得有点麻烦，再对比下 Kotlin 的写法： 12val tmp = a?.b?.cval len = a?.b?.c?.length // c 的长度，或者 null]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub 从源分支更新 Fork 分支]]></title>
    <url>%2Fnotes%2F2017%2F10%2F23%2Fgithub-fork-update-from-upstreamo-riginal%2F</url>
    <content type="text"><![CDATA[在 GitHub 上操作进行更新源代码，和一般「Pull requests」的原理是一样的，只是主次关系需要对调一下，「Pull requests」是将 Fork 分支的改动合并到源 Master 上，而这里是将源分支 Master 的改动，更新到 Fork 分支上。 GitHub 操作Step1在 Fork 分支创建一个合并请求(New pull request)： Step2「New pull request」之后，需要对调 Base： Step3创建合并请求 Step4填写合并说明，（Update upstream：更新上游代码的意思） Step5这一步需要解决冲突，然后「Merge pull request」，最后不要忘记「Confirm merge」 通过命令行进行更新源代码123456789101112# clone你fork的项目$ git clone git@github.com:UserName/your-forked-repo.git$ cd fork-repo# 添加一个叫upstream的remote$ git remote add upstream git://github.com/original-dev-username/repo-you-forked-from.git# 然后fetch$ git fetch upstream# pull最新的代码到你的主分支中$ git pull upstream master]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[autojump]]></title>
    <url>%2Fnotes%2F2017%2F10%2F23%2Fmark-mac-autojump%2F</url>
    <content type="text"><![CDATA[切换目录，在命令行的操作中没有比这个更频繁的动作了，又有什么比一遍又一遍 “cd ls cd ls ……” 更令人沮丧的事情呢，即便是使用了 zsh Alias。如果你不是百分百确定你想要进入的目录名字，那么你就避免不了频繁的使用这该死的 “cd ls”，但也可能离你的目标目录越走越远，越走越远。 所幸的是，现在大量的终端和 shell 都提供了强大的自动补全功能。但是，你仍需一直疯狂的敲击 TAB 来干这事。如果你是一个懒惰的人，和我一样，那么，当你发现 autojump 的时候，一定会对它感到惊喜不已。 autojump 是一个命令行工具，它允许你可以直接跳转到你喜爱的目录，而不用管你现在身在何处。 autojump 的基本用法autojump 的工作方式非常简单，它会在你每次启动命令的时候记录你的当前位置，并将它添加进数据库中。这样一来，某些目录添加的次数多于其它目录时，就代表着它比其他目录更重要，日常使用更频繁，那么它的“权重”就更大。 现在，无论你在哪个目录，你都可以使用下面的语法来直接跳转到目标目录： 1$ autojump [目录名 Or 目录名的一部分] 注意，你不需要输入完整的名称，因为 autojump 会检索它的数据库，并返回最可能的结果。 例如，我们有下面的目录结构： 那么，现在我想进入到 doc 目录，不管你当前在哪里，只需要在命令行输入下面的命令即可： 1$ j do # j 是autojump的默认别名 另一个比较好的功能是，autojump 支持 zsh 自动补全。如果你不确定那里是不是你要跳转的地方，TAB 键就会列出完整路径，再次 TAB 可进行选择： 1234567891011# 这是我电脑运行的结果$ j d__d__1__/Users/username/prj/Androidd__2__/Users/username/.emacs.dd__3__/Users/username/prj/Android/trunk/hAndroidd__4__/Users/username/prj_workspace/aDroidd__5__/Users/username/prj_outsourcing/trunk/MonitoingReportTablesDroidd__6__/Users/username/.vim/bundled__7__/Users/username/Downloadsd__8__/Users/username/prj/Android/trunk/ispatchAppd__9__/Users/username/prj/PAndroid 修改权重，如果你突然想要把当前目录变成你使用最频繁的文件夹，你可以在该目录通过命令的参数 i 来手工增加它的权重： 1$ autojump -i [权重] 这将使得该目录更可能被选择跳转。相反的例子是在该目录使用参数 d 来减少权重： 1$ autojump -d [权重] 要跟踪所有的改变，输入： 1$ autojump -s 这样，会显示数据库中所有的统计数据。 清除不再存在的目录： 1$ autojump --purge 对于高级用户，你可以访问目录数据库，并修改它的内容。可以使用下面的命令来手动添加一个目录： 1$ autojump -a [目录] 简言之，autojump 的简单实用将会受到所有命令行用户的欢迎。]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>Mark</tag>
        <tag>备忘录</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 终端环境 iTerm2 + Zsh + Oh My Zsh]]></title>
    <url>%2Fnotes%2F2017%2F10%2F19%2Fmark-memoa-iterm2-zsh%2F</url>
    <content type="text"><![CDATA[iTerm2 is a terminal emulator. It works on Macs with macOS 10.8 or newer. iTerm2iTerm2 官方网站：http://www.iterm2.com/ Solarized 配色Solarized 主页：http://ethanschoonover.com/solarized Get Solarized 配色包，这里使用 Git 方式克隆： 1$ git clone git://github.com/altercation/solarized.git 找到solarized/iterm2-colors-solarized/，双击添加配色 Zsh 配置安装Zsh 是 Mac 系统自带的，一般来说不是最新版本，可通过 Homebrew 安装最新版本： 1$ brew install zsh 修改默认 Shell在 /etc/shells 文件中加入 /usr/local/bin/zsh，并运行如下命令： 1$ chsh -s /usr/local/bin/zsh Oh My ZshOh My Zsh 是用来管理 Zsh 配置的，自带了很多很好用的基本配置。安装也非常简单，可参考主页：https://github.com/robbyrussell/oh-my-zsh。 Oh My Zsh 目录文件在 ~/.oh-my-zsh，包含了各种 Theme 和 Plugs，配置文件在 ~/.zshrc。 如需「修改/添加」配置，可编辑 ~/.zshrc。例如启用插件 Git、Autojumps，只需修改 ~/.zshrc 中对应的 pluins (大概在55行左右)，配置如下形式： 1$ plugins=(git autojumps osx) 快捷键 - 备忘录 选中即复制，鼠标中键粘贴 ⌃ + u：清空当前行 ⌃ + a：移动到行首 ⌃ + e：移动到行尾 ⌃ + f：向前移动 ⌃ + b：向后移动 ⌃ + p：上一条命令 ⌃ + n：下一条命令 ⌃ + r：搜索历史命令 ⌃ + y：召回最近用命令删除的文字 ⌃ + h：删除光标之前的字符 ⌃ + d：删除光标所指的字符 ⌃ + w：删除光标之前的单词 ⌃ + k：删除从光标到行尾的内容 ⌃ + t：交换光标和之前的字符 ⌘ + Click：打开文件、文件夹和链接 ⌘ + n：新建窗口 ⌘ + t：新建标签页 ⌘ + w：关闭当前页 ⌘ + 数字 &amp; ⌘ + 方向键：切换标签页 ⌥⌘ + 数字：切换窗口 ⌘ + enter：切换全屏 ⌘ + d：左右分屏 ⇧⌘ + d：上下分屏 ⌘ + ;：自动补全历史记录 ⇧⌘ + h：自动补全剪贴板历史 ⌥⌘ + e：查找所有来定位某个标签页 ⌘ + r &amp; ⌃ + l：清屏 ⌘ + /：显示光标位置 ⌥⌘ + b：历史回放 ⌘ + f：查找，配合使用 Tab、「⇧ + Tab」进行向右、向左补全，「⌥ + Enter」将查找结果输入终端]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>Mark</tag>
        <tag>备忘录</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APK 混淆打包]]></title>
    <url>%2Fnotes%2F2017%2F10%2F17%2Fandroid-proguard-project%2F</url>
    <content type="text"><![CDATA[Java 编译后生成的 .class 可以很轻易地被反编译。混淆能让反编译的代码可读性变得很差，而且还能显著的减少 APK 包的大小。 相信搞 Android 开发的朋友都知道这个道理「混淆能让反编译的代码可读性变得很差，而且还能显著的减少 APK 包的大小」，但未必都会去做，大部分选择不配置的理由是觉得混淆麻烦，甚至是说，有点乱，不想去触碰这个“雷区”。 曾经不止一次旁敲侧击的从身边的朋友打听，回答大抵相同：「当然，使用自带的功能，如果 Google 连这个都没做到，那真是太 Low 了」，听到这话我就放心了，心里默默「呵呵」了一声。 嗨，说到这里，插入一个话题：「如何反编译 APK，并查看源码呢？」，这里推荐两篇博文：「Android 代码 混淆- 原来如此简单」和「Android APK反编译就这么简单 详解」。看了这两篇博文之后，相信你一定会破骂两句「MD，辛辛苦苦费了老大劲搞出来的项目，几分钟就被人把源码破了，真TM蛋疼」。 从这里开始首先，需要告知 Gradle 需要混淆。在 app/build.gradle 中把 minifyEnabled 设置为 true，代码如下： 12345678910111213buildTypes &#123; // release模式 release &#123; // 是否进行混淆，默认false minifyEnabled true // Zipalign 优化 zipAlignEnabled true // 移除无用的资源文件 shrinkResources true // 混淆文件的位置 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125;&#125; 混淆模板「Android SDK」已经内置了默认的混淆配置文件 (android-sdk/tools/proguard/proguard-android.txt)。但只有这个是不够的，我们还需要添加自己的配置，「AS」在创建 Project 之初就已经为我们生成了这么一个文件 app/proguard-rules.pro，接下来，所做的混淆配置都必须写入这个文件。 常规的混淆模板这里给出一个常规的混淆模板，直接复制使用即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150-optimizationpasses 5 # 指定代码的压缩级别-verbose # 混淆时是否记录日志-ignorewarnings # 忽略警告，避免打包时某些警告出现-keepattributes SourceFile,LineNumberTable-dontshrink # 不压缩输入的类文件-dontoptimize # 不优化输入的类文件# 手动启用support keep注解 可使用注解@Keep-dontskipnonpubliclibraryclassmembers-printconfiguration-keep,allowobfuscation @interface android.support.annotation.Keep-keep @android.support.annotation.Keep class *-keepclassmembers class * &#123; @android.support.annotation.Keep *;&#125;##--- For:Remove log ----assumenosideeffects class android.util.Log &#123; public static boolean isLoggable(java.lang.String, int); public static int v(...); public static int i(...); public static int w(...); public static int d(...); public static int e(...);&#125;-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;# 不混淆R文件-keep class *.R-keepclasseswithmembers class **.R$* &#123; public static &lt;fields&gt;; &#125;-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;# BuildConfig-keep class *.BuildConfig-keepclasseswithmembers class **.BuildConfig$* &#123; public static &lt;fields&gt;; &#125;-keepclassmembers class **.BuildConfig$* &#123; public static &lt;fields&gt;;&#125;##--- For:保持自定义控件类不被混淆 ----keepclasseswithmembers class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet);&#125;-keepclasseswithmembers class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;# 保留Annotation-keepattributes *Annotation*-keep public class com.google.vending.licensing.ILicensingService-keep public class com.android.vending.licensing.ILicensingService-keepclasseswithmembernames class * &#123; # 保持 native 方法不被混淆 native &lt;methods&gt;;&#125;-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;; &#125;##--- For:Serializable ----keepnames class * implements java.io.Serializable-keep class * implements java.io.Serializable &#123; *; &#125;-keepclassmembers class * implements java.io.Serializable &#123; *; &#125;-keepnames class * implements java.lang.Cloneable-keep class * implements java.lang.Cloneable &#123; public *; &#125;##---------------- 不被混淆，这里列出一些常规不需要混淆的 -----------------dontwarn org.mockito.**-dontwarn sun.reflect.**-dontwarn android.test.**-keep class org.junit.** &#123; *; &#125;-dontwarn org.junit.**-keep class junit.** &#123; *; &#125;-dontwarn junit.**-keep class sun.misc.** &#123; *; &#125;-dontwarn sun.misc.**-keep class com.google.** &#123; *; &#125;-keep class org.apache.** &#123; *; &#125;-dontwarn android.support.**-keep class * extends android.app.Activity-keep class * extends android.app.Application-keep class * extends android.app.Service-keep class * extends android.content.BroadcastReceiver-keep class * extends android.content.ContentProvider-keep class * extends android.app.backup.BackupAgentHelper-keep class * extends android.preference.Preference-keep class * extends android.view.View-keep class com.android.vending.licensing.ILicensingService-keep class android.telephony.CellLocation-keep class android.view.View-keepclassmembers public class * extends android.view.View &#123; void set*(***); *** get*(); public *; protected *;&#125;-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View); public *; protected *;&#125;# 保持枚举 enum 类不被混淆-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;# 保持 Parcelable 不被混淆-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;-keep class * extends android.support.v4.app.Fragment&#123; public *; protected *;&#125;-keep class * extends android.app.Fragment&#123; public *; protected *;&#125;-keep class * extends android.app.Application&#123; public *; protected *;&#125;# Dialog不参与混淆-keep class * extends android.app.Dialog-keep class * implements android.content.DialogInterface-keep class * extends android.widget.PopupWindow# Adapter不参与混淆-keep class * extends android.view.View-keep class * implements android.widget.Adapter-keep class * extends android.widget.BaseAdapter-keep class * implements android.widget.ListAdapter 日志数据模板记录生成的日志数据(可以不用配置)，gradle build 时在本项目根目录输出： 12345##---------------- 记录生成的日志数据，这里列出一些常规不需要混淆的 -----------------dump class_files.txt # apk 包内所有 class 的内部结构-printseeds seeds.txt # 未混淆的类和成员-printusage unused.txt # 列出从 apk 中删除的代码-printmapping mapping.txt # 混淆前后的映射 Android Support Lib 模板如果使用了 Android 扩展包，添加下面的配置准没错： 1234567891011121314151617181920212223242526272829# 保留android support包# android support eg. v4、v7、annotations、design、compat==-keep class android.support.** &#123; *; &#125;-keepclassmembers class * implements android.support.v4.app.FragmentManager &#123; *;&#125;-dontwarn android.support.**-keep class dagger.** &#123; *; &#125;-keep class android.app.** &#123; *; &#125;-dontwarn android.app.**# nineoldandroids-keep class com.nineoldandroids.** &#123; *; &#125;-keep public class com.nineoldandroids.animation.** &#123; public *; &#125;-keep public class com.nineoldandroids.view.ViewHelper &#123; public *; &#125;-keep class com.android.test.** &#123; *; &#125;##--- For:android-support-v4 ----dontwarn android.support.v4.**-keep class android.support.v4.** &#123; *; &#125;-keep interface android.support.v4.app.** &#123; *; &#125;-keep class * extends android.support.v4.** &#123; *; &#125;-keep public class * extends android.support.v4.**-keep public class * extends android.support.v4.widget-keep class * extends android.support.v4.app.** &#123;*;&#125;-keep class * extends android.support.v4.view.** &#123;*;&#125; 常用第三方模块的混淆对于第三方库的使用，最好是 -dontwarn 与 -keep 配套使用。 下面是一些常用第三方包的混淆配置。如：gson zxin ButterKnife OkHttp RxJava RxAndroid Google、阿里巴巴、百度等，模块以空行为准，复制可使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172# gson 用到Gson解析包的，直接添加下面这几行就能成功混淆，不然会报错# -libraryjars libs/gson-2.8.0.jar-keepattributes Signature-dontskipnonpubliclibraryclassmembers-dontskipnonpubliclibraryclasses# -keep class com.google.** &#123; *; &#125;-keep class sun.misc.Unsafe &#123; *; &#125;-keep class com.google.gson.** &#123; *;&#125;-keep class com.google.gson.examples.android.model.** &#123; *; &#125;-keep class com.google.** &#123; &lt;fields&gt;; &lt;methods&gt;;&#125;-dontwarn com.google.gson.**##--- For:Gson ----keepattributes *Annotation*-keep class sun.misc.Unsafe &#123; *; &#125;-keep class com.idea.fifaalarmclock.entity.***-keep class com.google.gson.stream.** &#123; *; &#125;# zxing-keep class com.google.zxing.** &#123; *; &#125;# butterknife -keep class butterknife.*-keep class butterknife.** &#123; *; &#125;-dontwarn butterknife.internal.**-keep class **$$ViewBinder &#123; *; &#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;fields&gt;; &#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;methods&gt;; &#125;-keep public class * implements butterknife.Unbinder &#123; public &lt;init&gt;(...); &#125;# AMap_Location-keep class com.aps.** &#123; *; &#125;-keep class com.amap.** &#123; *; &#125;-keep class com.autonavi.** &#123; *; &#125;-keep class com.amap.api.** &#123; *; &#125;-keep class com.amap.api.location.** &#123; *; &#125;# commons-cli-keep class org.apache.commons.cli.** &#123; *; &#125;# commons-codec-keep class org.apache.commons.codec.** &#123; *; &#125;# commons-logging-keep class org.apache.** &#123; *; &#125;-keep class org.apache.commons.** &#123; *; &#125;-keep class org.apache.commons.lang3.** &#123; *; &#125;-keep class org.apache.commons.logging.** &#123; *; &#125;-keepnames class * implements org.apache.commons.logging.Log# converter-gson-keep class retrofit2.** &#123; *; &#125;# hamcrest-core-keep class org.hamcrest.** &#123; *; &#125;-keep class org.hamcrest.core.** &#123; *; &#125;-keep class org.hamcrest.internal.** &#123; *; &#125;# httpclient/httpmime/httpcore-keep class org.apache.http.** &#123; *; &#125;-dontwarn org.apache.http.**# javawriter-keep class com.squareup.javawriter.** &#123; *; &#125;# javax.inject javax.annotation jsr-keep class javax.** &#123; *; &#125;-keep class javax.inject.** &#123; *;&#125;-keep class javax.annotation.** &#123; *; &#125;# junit-keep class junit.** &#123; *; &#125;-keep class org.junit.** &#123; *; &#125;# logging-interceptor-keep class okhttp3.logging.** &#123; *; &#125;# okhttp-keep class okio.** &#123; *; &#125;-keep class okhttp3.** &#123; *; &#125;-keep class com.squareup.okhttp.** &#123; *; &#125;-dontwarn okio.**# reactive-streams-keep class org.reactivestreams.** &#123; *; &#125;# retrofit2-keep class retrofit2.** &#123; *; &#125;-keep class com.jakewharton.retrofit2.** &#123; *; &#125;-dontwarn retrofit2.**# org.apache.heep.legacy-keep class android.net.** &#123; *; &#125;-keep class com.android.internal.http.** &#123; *; &#125;-keep class org.apache.http.** &#123; *; &#125;-keep class org.apache.commons.codec.** &#123; *; &#125;-keep class org.apache.commons.logging.** &#123; *; &#125;# rxjava rxandroid-keep class rx.** &#123; *; &#125;-keep class rx.android.** &#123; *; &#125;-keep class io.reactivex.** &#123; *; &#125;-keep class org.reactivestreams.** &#123; *; &#125;# rxbinding-keep class com.jakewharton.** &#123; *; &#125;-keep class com.jakewharton.rxbinding.** &#123; *; &#125;# stream-keep class com.annimon.stream.** &#123; *; &#125;# stetho-keep class com.facebook.** &#123; *; &#125;-keep class com.facebook.stetho.** &#123; *; &#125;-keep class com.facebook.stetho.okhttp.** &#123; *; &#125;# libmmsdk mta-sdk open-sdk-keep class com.tencent.** &#123; *; &#125;# fastjason android-keep class com.alibaba.** &#123; *; &#125;-keep class com.alibaba.fastjson.** &#123; *; &#125;# 百度sdk-keep class com.baidu.** &#123; *; &#125;-keep class vi.com.** &#123; *; &#125;-keep class com.baidu.location.** &#123; *; &#125;-dontwarn com.baidu.**-keep class com.sina.** &#123; *; &#125;-keep class com.weibo.** &#123; *; &#125;-keep class com.alibaba.** &#123; *; &#125;-keep class android.net.http.** &#123; *; &#125;-dontwarn com.sina.**-dontwarn com.tencent.**-dontwarn com.alibaba.**-keep class com.alipay.** &#123; *; &#125;-keep class com.squareup.** &#123; *; &#125;-keep class com.squareup.picasso.** &#123; *; &#125;-keep class com.ut.*-keep class com.samsung.android.sdk.** &#123; *; &#125;-keep class com.ta.utdid2.** &#123; *; &#125;-keep class com.ut.device.** &#123; *; &#125;-keep class a.** &#123; *; &#125;-keep class b.** &#123; *; &#125;-keep class c.** &#123; *; &#125;-keep class d.** &#123; *; &#125;-keep class e.** &#123; *; &#125;-keep class f.** &#123; *; &#125;-keep class g.** &#123; *; &#125;-keep class h.** &#123; *; &#125;-keep class i.** &#123; *; &#125;-keep class j.** &#123; *; &#125;-keep class k.** &#123; *; &#125;-keep class l.** &#123; *; &#125;-keep class m.** &#123; *; &#125;-keep class n.** &#123; *; &#125;-keep class o.** &#123; *; &#125;-keep class p.** &#123; *; &#125;-keep class q.** &#123; *; &#125;-keep class r.** &#123; *; &#125;-keep class s.** &#123; *; &#125;-keep class t.** &#123; *; &#125;-keep class u.** &#123; *; &#125;-keep class v.** &#123; *; &#125; 主程序混淆配置对 App 来说，Model 层数据是不应该混淆的，尤其是参与网络请求的 Request 相关数据 1234-dontwarn xxx.model.**-keep class xxx.model.** &#123; *; &#125;## == 采坑在 Release 版本混淆之后，有些像「友盟」、「百度」这样的统计系统会出现 NullPointerException，这个是比较要命的，排查错误无法定位到具体位置，最终的解决方案是在 proguard-rules.pro 中添加如下代码即可： 1-keepattributes SourceFile,LineNumberTable]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
        <tag>ProGuard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无聊的汉字多胞胎：汆氽]]></title>
    <url>%2Fnotes%2F2017%2F10%2F16%2Fhanzi-cuan-tun%2F</url>
    <content type="text"><![CDATA[闲无聊无聊的汉字多胞胎入 cuan 汆，人 tun 氽 就喜欢这么简单粗暴、直截了当，上图。]]></content>
      <categories>
        <category>无聊</category>
      </categories>
      <tags>
        <tag>无聊</tag>
        <tag>蛋疼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无聊的汉字多胞胎：火炎焱燚]]></title>
    <url>%2Fnotes%2F2017%2F10%2F16%2Fhanzi-huo-yan-yan-yi%2F</url>
    <content type="text"><![CDATA[闲无聊无聊的汉字多胞胎横 xu 戌，点 shu 戍，空心 wu 戊 我可能是太无聊了。。。领导看到会是什么心情：「最近玩舒服了，工作不饱和，赶明儿给你多派点活」。]]></content>
      <categories>
        <category>无聊</category>
      </categories>
      <tags>
        <tag>无聊</tag>
        <tag>蛋疼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 搭建 GitHub 博客（III）- NexT 主题配置]]></title>
    <url>%2Fnotes%2F2017%2F10%2F13%2FHexo-GitHub-NexT-Config-3%2F</url>
    <content type="text"><![CDATA[PS：本博是在 MAC 环境下进行操作的本博主要介绍 NexT 主题的配置 NexT 是一款简洁优雅且功能比较齐全的主题，配置比较简单，只需要稍微修改配置文件即可。Hexo 有两份主要的配置文件，其名称都是 _config.yml。其中一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件 安装 NexTHexo 安装非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具安装步骤如下。 下载主题12$ cd your-hexo-site # 这里是有前面的目录 ~/Blog$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题当克隆/下载完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next，即theme: next，至此，NexT 主题就安装好了。 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s --debug。 当命令行输出中提示出： hexo s –debug INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 使用浏览器访问 http://localhost:4000 即可看到效果。 主题配置参考：NexT 配置，这里有详细的说明。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 搭建 GitHub 博客（II）- Hexo +「GitHub Pages」部署]]></title>
    <url>%2Fnotes%2F2017%2F10%2F13%2FHexo-GitHub-NexT-Config-2%2F</url>
    <content type="text"><![CDATA[PS：本博是在 MAC 环境下进行操作的本博主要介绍 Hexo 的配置安装，以及如何部署博客到 GitHub参考：Hexo 安装与初体验 安装12345$ cd ~$ sudo npm install hexo-cli -g$ hexo init Blog$ cd Blog$ npm install 安装成功，Blog 文件夹的目录结构看起来会像下面这个样子： 12345678910111213.├── _config.yml├── db.json├── node_modules│ ├── JSONStream│ │ ├── LICENSE.APACHE2│ │ ├── LICENSE.MIT│ │ ├── examples│ │ │ └── all_docs.js│ │ ├── index.js│ │ ├── package.json│ │ ├── readme.markdown│ │ └── test 体验站点123$ hexo clean$ hexo generate （简写：hexo g）$ hexo server （简写：hexo s） 默认状态下，网站是运行在 http://localhost:4000 创建你的第一篇文章运行以下命令，可生成一篇文章，刷新 http://localhost:4000 即可看到新生成的文章。 1$ hexo new "the-first-one" 同时在 ~\Blog\source_posts 目录下会生成一个名为「the-first-one.md」的文件，编辑该文件，刷新 http://localhost:4000 即可看到修改后的结果。 文件默认会为我们添加 Title 12345678---title: the-first-one # 文章标题date: 2017-10-13 12:00:07 # 发表日期categories: blog # 文章文类tags: # 文章标签 - 博客 - 文章 --- 生成静态网页1$ hexo generate （简写：hexo g） 生成静态网页，强烈推荐使用下面的方式： 123$ hexo clean$ hexo g$ hexo s 部署到 GitHub经过上面的一系列步骤（其实也没几步），我们终于可以在本地访问自己的 Blog 了。纳尼，只能在本地访问？那我费这么大劲干嘛呢，还不如写个静态 Markdown 文件。我们需要的是随时随地访问，同行之间的相互分享，要达到这个效果还需一步，即，部署到 GitHub 上。一般的做法是，在本地调试编辑好文章后再推送到 GitHub 上。下面是部署到 GitHub 的过程。 前提是，你已经拥有了自己专属的「GitHub Pages」。如果还没有「GitHub Pages」，请参考：Hexo 搭建 GitHub 博客（I）- 环境搭建 安装自动部署插件初始化博客时运行的 npm install 命令默认并没有安装这个插件，所以要手动安装： 1$ npm install hexo-deployer-git 修改配置文件这里的配置文件指站点配置文件，即，~/Blog/_config.yml，找到 deploy 标签，添加你的「GitHub Pages」路径，如下（替换「repo」为你的 GitHub 路径即可）： 部署 1$ hexo deploy 部署过程中会提示输入你的 GitHub 账号和密码，等待命令运行完成即可。部署完成后，在浏览器中访问 https://yoursname.github.is，如：https://rogerscj.github.io，这时就能看到你在本地调试好的博客了。 部署建议，FYI：上面的部署方式，我并不是很推荐，这里给出我平时的操作方式在 Blog 下新建一个专门用于部署的目录，deployHub，我的路径为 ~/Blog/deployHub发布脚本 deploy.sh，脚本内容如下： 123456789$ hexo clean$ hexo generate$ cp -R public/* deployHub/RogersCj.github.io$ cd deployHub/RogersCj.github.io$ git add .$ git commit -m "update"$ git push origin master$ cd ..$ cd .. 每次发布运行脚本 deploy.sh 即可 1./deploy.sh Hexo 常用命令常用命令12345678910111213141516$ hexo init [folder] # 新建一个网站$ hexo new "postName" # 新建文章$ hexo generate # 生成静态页面至public目录$ hexo server # 开启预览访问端口（默认端口4000，'ctrl + c'关闭server）$ hexo deploy # 将.deploy目录部署到GitHub$ hexo help # 查看帮助$ hexo version # 查看Hexo的版本$ hexo --draf # 显示草稿$ hexo --debug # 调试模式$ hexo --silent # 简洁模式$ $ hexo --config custom.yml # 自定义配置文件的路径$ hexo s -g # 生成静态文件并启动本地服务 命令简写1234$ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>GitHub</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 搭建 GitHub 博客（I）- 环境搭建]]></title>
    <url>%2Fnotes%2F2017%2F10%2F13%2FHexo-GitHub-NexT-Config-1%2F</url>
    <content type="text"><![CDATA[PS：本博是在 MAC 环境下进行搭建的本博主要介绍「GitHub Pages」的相关环境搭建 在平常的工作和生活中，记录一些笔记是必不可少的。设备更新换代又日趋频繁，免不了丢三落四，搭建一个便捷、稳定的个人站点还是挺有必要的，如果能将一些有用的笔记分享给有相同需求的同伴，那再好不过了。「GitHub Pages」就是一个不错的选择。 搭建流程大致分下面几步： 注册一个 Github 拥有一个 GitHub Pages 配置本地 Hexo 环境 绑定自己的域名（可直接使用 Github Pages 二级域名） 几个简单的概念GitHub Pages如果你对编程有所了解，就一定听说过 GitHub。它号称程序员的 Facebook，有着极高的人气，也是目前最流行的代码仓库，许多重要的项目都托管在上面。 GitHub Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在Github上。这里有更详细的介绍 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。参见 Hexo 文档 环境配置安装Git下载地址：http://git-scm.com/downloads 安装 NodeJS参考地址：安装Node.js下载地址：http://nodejs.org/download/ 安装 Hexo1$ sudo npm install hexo-cli -g 安装成功后，会出现诸如 -- hexo-cli@1.0.3 的信息。 快速开始从注册一个 GitHub 账号开始要使用「GitHub Pages」，首先你要注册一个 GitHub 账号，GitHub 是全球最大的同性交友网站，你值得拥有^_^。 创建 GitHub Pages仓库的名字要和你的账号对应，如：rogerscj.github.io这里介绍2种创建「GitHub Pages」的方式，第一种比较官方；第二种最简单，连带 Hexo 一起被创建好。 官方的方式创建Create repository 仓库的名字要和你的账号对应设置默认的页面（如果决定使用 Hexo，这一步可省略，后面会将 Hexo 导入）参考：GitHub Pages 克隆我的博客模板PS：如果希望一步一步走完 Hexo 部署到 GitHub，可略过下面的篇幅修改成你自己的仓库名 yoursname.github.io，如：Rogerscj.github.io 注册完成后搜索 rogerscj.github.io 进入我的仓库 点击右上角的 Fork 将我的仓库拉倒你的账号下： 稍等片刻，点击刷新，你会看到 Fork 成功的页面： 修改仓库名，并删除文件 CNAME 文件的内容： 在浏览器中访问 https://yoursname.github.is，如：https://rogerscj.github.io，这时就能看到你博客了，PS: 博文内容保留了我的^_^。 OK，至此完毕，完美！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>GitHub</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APK 签名文件]]></title>
    <url>%2Fnotes%2F2017%2F10%2F12%2Fapk-signature%2F</url>
    <content type="text"><![CDATA[标记，Tag 一下记录下签名生成的过程，方便下次使用。 简单来说，签名就是个标识，它可以保证 APP 正常升级，并且不被别人覆盖。 Tools java jdk keytool 密钥和证书管理工具,可以用来生成证书 使用 keytool 生成证书： 12# 文件名和别名相同，为: test.keystore$ keytool -genkey -alias test.keystore -keyalg RSA -validity 20000 -keystore test.keystore 参数解释: -genkey 产生证书文件 -keystore 指定密钥库的.keystore文件中 -keyalg 指定密钥的算法,这里指定为RSA(非对称密钥算法) -validity 为证书有效天数，这里我们写的是10000天 -alias 产生别名 查看信息1$ keytool -list -keystore test.keystore]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity 生命周期]]></title>
    <url>%2Fnotes%2F2017%2F10%2F11%2FActivity-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[这是个被谈烂了的问题，网上介绍的文章也铺天盖地。但是，作为一名有轻微强迫症的攻城狮，想写写 Android 相关的东西，如果不从这里入手，总觉得心里缺了点啥似的，也就不免俗了，从这里开始吧。 生命周期流程相信学习安卓的人对 Android Activity 的生命周期活动并不陌生，下图详细而直观得表现了 Activity 各生命周期间的关系。 正常完整的流程走向1onCreate –&gt; onStart –&gt; onPostCreate –&gt; onResume –&gt; onPostResume –&gt; onPause –&gt; onStop –&gt; onDestroy onCreatecreate 表示创建，这是 Activity 生命周期的第一个方法，也是我们在 android 开发中接触的最多的生命周期方法。它本身的作用是进行 Activity 的一些初始化工作，比如使用 setContentView 加载布局，对一些控件和变量进行初始化等。此时 Activity 还在后台，为非可见非可视状态。 onStartstart 即启动，这是 Activity 生命周期的第二个方法。此时 Activity 已经可见了，但是还没出现在前台，我们还看不到，无法与 Activity 交互。其实将 Activity 的初始化工作放在这也没有什么问题，放在 onCreate 中是由于官方推荐的以及我们开发的习惯。此时 Activity 为非可视状态。 onContentChanged当 Activity 的布局改动时，即 set 或 add ContentView 执行完毕时会调用该方法。Activity 中各种 View 的初始化，如：findViewById()，都可以放到该方法中。 onResumeresume 表示继续、重新开始。经过前两个阶段的初始化，此时 Activity 已处于栈顶，用户可交互。此时 Activity 为可视状态。 onPostCreate、onPostResumeonPostCreate、onPostResume方法分别在 onCreate、onResume方法彻底执行完毕后回调。 onPause暂停状态。该状态下，Activity 的部分被另外一个 Activity 所遮盖，另外的 Activity 来到前台，但是半透明的，不会覆盖整个屏幕。被暂停的 Activity 不再接受用户的输入且不再执行任何代码。 onStoponStop 在整个窗口被完全遮盖才会触发，此时 Activity 不可见，处于后台运行。触发 onStop 之前必定会触发onPause。 onSaveInstanceState、 onRestoreInstanceStateonSaveInstanceState 是恢复实例的状态，但需要注意 onSaveInstanceState 和 onRestoreInstanceState “不一定”是成对的被调用的，onRestoreInstanceState 被调用的前提是，Activity A “确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用。 长时间处于 Stop 形态，系统可能回收 Activity 比如旋转屏幕: 1onResume –&gt; onSaveInstanceState() –&gt; onDestory 重新创建: 1onCreate –&gt; onRestoreIntanceState() –&gt; onResume 返回当前（按机器返回键）12onPause –&gt; onStop –&gt; onDestoryonRestart –&gt; onStart –&gt; onResume –&gt; onPostResume 屏幕待机（黑掉）1onPause Home键退出1onPause –&gt; onSaveInstanceState –&gt; onStop 旋转屏幕默认屏幕旋转会重新创建，配置 configChanges 可改变这一现象 12android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;（sdk&gt;13时需加上screenSize）onPause –&gt; onStop –&gt; onDestory –&gt; onCreate –&gt; onStart –&gt; onPostCreate –&gt; onResume –&gt; onPostResume]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adb 录屏]]></title>
    <url>%2Fnotes%2F2017%2F10%2F11%2FAdb-%E5%BD%95%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[记录2个捕获屏幕的 adb 命令。 截屏「Screencap」1$ adb shell screencap -p /sdcard/screen.png 录制屏幕「Screenrecord」录制默认分辨率，默认 4Mbps，时间为 180s 的 MP4 视频，并且保存到 Sdcard 上 12$ adb shell screenrecord /sdcard/yourFileName.mp4$ adb pull /sdcard/yourFileName.mp4 ~/mp4File/ 第三方工具AndroidTool]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Adb</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 插件配置: FindBugs]]></title>
    <url>%2Fnotes%2F2017%2F10%2F11%2FAndroid-Studio-%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE-FindBugs%2F</url>
    <content type="text"><![CDATA[FindBugs 是一个静态分析工具，它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比来发现可能的问题，可以以独立的 JAR 包形式运行，也可以作为集成开发工具的插件形式存在。 安装FindBugs插件首先需要在 Android Studio 中安装 FindBugs 的插件。在 Android Studio 中找到「Preferences/Plugins」选项，在该复选框中通过上方搜索，或将 FindBugs 插件下载到本地，使用「Install plugin from disk」进行安装。安装示意图如下所示，安装完成后需要重启 Android Studio。 扩展优化安装「Android Code Arbiter」插件FindBugs 插件具有着极强的可扩展性，只需要将扩展的 JAR 包导入 FindBugs 插件，重启，即可完成相关功能的扩展。 FindBugs 插件安装后，将会在 「Preferences/Other Settings」 中找到安装插件的选项 FindBugs-IDEA，点击中测靠左的「+」号，在弹出的选框中选择 「4.Install plugin from disk」，在弹出的选框中选择下载的 Android Code Arbiter 的 jar 包，点击 OK，此时会发现插件已经安装了，点击 OK，并重启 Android Studio 完成插件安装。 安装部分示意图，如下所示。 添加过滤在没有进行任何过滤的情况下找到的结果可能会令人失望，它会把自动生成的代码也考虑在内。因此我们在进行 Bug 查找的时候首先需要添加过滤 下面是过滤掉 Android 自动生成的代码的配置文件「findbugs-exclude.xml」 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;FindBugsFilter&gt; &lt;Match&gt; &lt;!-- ignore all issues in resource generation --&gt; &lt;Class name="~.*\.R\$.*"/&gt; &lt;/Match&gt; &lt;Match&gt; &lt;Class name="~.*\.Manifest\$.*"/&gt; &lt;/Match&gt; &lt;!-- &lt;Match&gt; &lt;Or&gt; &lt;Class name="~.*\.R\$.*"/&gt; &lt;Class name="~.*\.Manifest\$.*"/&gt; &lt;/Or&gt; &lt;/Match&gt; --&gt; &lt;!-- 测试用例警告 --&gt; &lt;Match&gt; &lt;Class name="~.*\.*Test"/&gt; &lt;Not&gt; &lt;Bug code="IJU"/&gt; &lt;!-- 'IJU' is the code for bugs related to JUnit test code --&gt; &lt;/Not&gt; &lt;/Match&gt;&lt;/FindBugsFilter&gt; 添加过滤文件，如下示意图]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>FindBugs</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 命令清单]]></title>
    <url>%2Fnotes%2F2017%2F10%2F10%2FGit-%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[参考Pro Gitgit - 简易指南阮一峰的网络日志 我们每天都在使用 Git ，但是除了 git push 和 git pull 还有多少命令是记得住的。下面是一些常用的 Git 命令，以供参考。 配置信息12345678910111213141516# 显示Git配置$ git config --list# 显示Git配置 global$ git config --list --global# 显示Git配置 local$ git config --list --local# 设置提交代码的用户信息$ git config [--global] user.name "name"$ git config [--global] user.email "email"# 设置当前仓库提交代码的用户信息 local$ git config --local user.name "name]"$ git config --local user.email "email" 创建新仓库12345# 初始化本地git仓库（创建新仓库）$ git init# clone远程仓库，包括这个项目的整个代码历史$ git clone [url] 查看信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 查看当前版本状态（是否修改）$ git status# 显示提交日志$ git log$ git log -5# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索commit历史$ git log -S [keyword]# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去n次提交$ git log -5 --pretty --oneline# 显示v2.0的日志$ git log v2.0# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached$ git diff --cached [file]# 比较与上一个版本的差异$ git diff HEAD^# 比较与HEAD版本lib目录的差异$ git diff HEAD -- ./lib# 比较远程分支master上有本地分支master上没有的$ git diff origin/master..master# 只显示差异的文件，不显示具体内容$ git diff origin/master..master --stat# 显示今天你写了多少行代码$ git diff --shortstat "@&#123;0 day ago&#125;"# 显示某个提交的详细内容(可只用commitid的前几位)$ git show [commit]$ git show dfb02e6e4f2f7b573337763e5c0013802e392818$ git show dfb02# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示HEAD提交日志$ git show HEAD# 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本$ git show HEAD^# 显示v2.0的日志及详细内容$ git show v2.0# 显示已存在的tag$ git tag# 显示当前分支的最近几次提交$ git reflog 增加/删除123456789101112131415161718192021222324# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有更改过的文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 递归删除$ git rm -r *# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415# 提交暂存区到仓库区$ git commit [file1] [file2] ... -m '[message]'# 合并上一次提交（用于反复修改）# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m 'message'# 将add和commit合为一步$ git commit -am 'message' # 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...# 提交时显示所有diff信息$ git commit -v 撤销1234567891011121314151617181920# 恢复暂存区的指定文件到工作区$ git checkout [file]$ git checkout .# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818$ git revert [commit]$ git revert dfb02e6e4f2f7b573337763e5c0013802e392818# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 远程同步123456789101112131415161718192021222324252627282930313233343536373839# 获取所有远程分支（不更新本地分支，另需merge）$ git fetch# 获取所有原创分支并清除服务器上已删掉的分支$ git fetch --prune# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 获取远程分支master并merge到当前分支$ git pull origin master# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]$ git pull origin dev# 上传本地指定分支到远程仓库$ git push [remote] [branch]$ git push origin master$ git push origin devV1.81$ git push orgin devV1.81:devV1.81# 删除远程仓库的hotfixes/BJVEP933分支$ git push origin :hotfixes/BJVEP933# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all# 把所有tag推送到远程仓库$ git push --tags 分支123456789101112131415161718192021222324252627282930313233343536373839404142434445# 显示本地分支# 显示远程分支# 显示所有本地和远程分支$ git branch$ git branch -r$ git branch -a# 显示包含提交50089的分支$ git branch --contains 50089# 显示所有已合并到当前分支的分支$ git branch --merged# 显示所有未合并到当前分支的分支$ git branch --no-merged# 新建分支，但依然停留在当前分支$ git branch [branch-name]# 新建分支，并切换到该分支$ git checkout -b [branch]# 切换到指定分支$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 合并指定分支到当前分支$ git merge [branch]# 合并远程master分支至当前分支$ git merge origin/master# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]# 合并分支到master$ git checkout master$ git merge --no-ff branch-name$ git push orgin master 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式汇总]]></title>
    <url>%2Fnotes%2F2017%2F10%2F10%2FRegular-Expression%2F</url>
    <content type="text"><![CDATA[数字校验 数字：^[0-9]*$ n位的数字：^\d{n}$ m-n位的数字：^\d{m,n}$ 至少n位的数字：^\d{n,}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$ 非零负整数：^\-[1-9][]0-9″*$ 或 ^-[1-9]\d*$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 字符校验 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;&#39;,;=?$\x22]+ 禁止输入含有~的字符：[^~\x22]+ 特殊需求表达式 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 或 ^http://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$ 或 ^(http|www|ftp|)?(://)?(\w+(-\w+)*)(\.(\w+(-\w+)*))*((:\d+)?)(/(\w+(-\w+)*))*(\.?(\w)*)(\?)?(((\w*%)*(\w*\?)*(\w*:)*(\w*\+)*(\w*\.)*(\w*&amp;)*(\w*-)*(\w*=)*(\w*%)*(\w*\?)*(\w*:)*(\w*\+)*(\w*\.)*(\w*&amp;)*(\w*-)*(\w*=)*)*(\w*)*)$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^($$\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00″, 和没有 “分” 的 “10000″ 和 “10,000″：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10″ 和 “10.2″ 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\u4e00-\u9fa5] 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\n\s*\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fnotes%2F2017%2F10%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>Testing</tag>
      </tags>
  </entry>
</search>
